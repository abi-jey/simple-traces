// Generated by Copilot
package backend

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"gorm.io/driver/postgres"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

// GORM Models with proper tags
type Trace struct {
	ID           string    `gorm:"primaryKey" json:"id"`
	Model        string    `json:"model"`
	Input        string    `json:"input"`
	Output       string    `json:"output"`
	PromptTokens int       `json:"prompt_tokens"`
	OutputTokens int       `json:"output_tokens"`
	Duration     int64     `json:"duration"`
	Metadata     string    `json:"metadata,omitempty"`
	Timestamp    time.Time `gorm:"index" json:"timestamp"`
}

type Span struct {
	SpanID       string    `gorm:"primaryKey" json:"span_id"`
	TraceID      string    `gorm:"index:idx_trace_id;index:idx_group_id" json:"trace_id"`
	ParentSpanID string    `json:"parent_span_id,omitempty"`
	Name         string    `json:"name"`
	StartTime    time.Time `gorm:"index:idx_start_time" json:"start_time"`
	EndTime      time.Time `json:"end_time"`
	DurationMS   int64     `json:"duration_ms"`
	StatusCode   string    `json:"status_code"`
	StatusDesc   string    `json:"status_description,omitempty"`
	Attributes   string    `gorm:"type:text" json:"attributes,omitempty"`
	Events       string    `gorm:"type:text" json:"events,omitempty"`
}

type SpanAttribute struct {
	ID        uint     `gorm:"primaryKey;autoIncrement" json:"-"`
	SpanID    string   `gorm:"index:idx_span_attr" json:"span_id"`
	TraceID   string   `gorm:"index:idx_trace_attr" json:"trace_id"`
	Key       string   `gorm:"index:idx_key" json:"key"`
	Type      string   `json:"type"`
	StringVal *string  `json:"string_val,omitempty"`
	IntVal    *int64   `json:"int_val,omitempty"`
	FloatVal  *float64 `json:"float_val,omitempty"`
	BoolVal   *bool    `json:"bool_val,omitempty"`
	JSONVal   *string  `gorm:"type:text" json:"json_val,omitempty"`
}

type Conversation struct {
	ID             string    `gorm:"primaryKey" json:"id"`
	ProjectID      string    `gorm:"index;default:'default'" json:"project_id"`
	FirstStartTime time.Time `json:"first_start_time"`
	LastEndTime    time.Time `gorm:"index" json:"last_end_time"`
	SpanCount      int       `json:"span_count"`
	Model          string    `json:"model,omitempty"`
}

type Project struct {
	ID        string    `gorm:"primaryKey" json:"id"`
	Name      string    `gorm:"not null" json:"name"`
	CreatedAt time.Time `gorm:"autoCreateTime" json:"created_at"`
	UpdatedAt time.Time `gorm:"autoUpdateTime" json:"updated_at"`
}

type SpanLink struct {
	ID            uint    `gorm:"primaryKey;autoIncrement" json:"-"`
	SpanID        string  `gorm:"index:idx_span_links" json:"span_id"`
	TraceID       string  `gorm:"index:idx_trace_links" json:"trace_id"`
	LinkedTraceID string  `gorm:"index:idx_linked_trace" json:"linked_trace_id"`
	LinkedSpanID  *string `json:"linked_span_id,omitempty"`
}

// Helper structs
type TraceGroup struct {
	TraceID        string    `json:"trace_id"`
	FirstStartTime time.Time `json:"first_start_time"`
	LastEndTime    time.Time `json:"last_end_time"`
	SpanCount      int       `json:"span_count"`
	Model          string    `json:"model,omitempty"`
}

type ConversationUpdate struct {
	ID        string
	ProjectID string
	Start     time.Time
	End       time.Time
	Count     int
	Model     string
}

type LinkedConversation struct {
	SpanID         string `json:"span_id"`
	RelatedSpanID  string `json:"related_span_id"`
	Relation       string `json:"relation"`
	ConversationID string `json:"conversation_id"`
}

// GormDB implements the Database interface using GORM
type GormDB struct {
	db *gorm.DB
}

// Database interface remains the same
type Database interface {
	CreateTrace(trace Trace) (string, error)
	GetTraces() ([]Trace, error)
	GetTracesPaginated(limit int, before time.Time) ([]Trace, error)
	GetTraceByID(id string) (*Trace, error)
	DeleteTrace(id string) error

	BatchInsertSpans(spans []Span) error
	GetSpans(limit int, before time.Time) ([]Span, error)
	DeleteSpansByTraceID(traceID string) (int64, error)
	DeleteSpansByGroupID(groupID string) (int64, error)

	BatchUpsertSpanAttributes(attrs []SpanAttribute) error
	DeleteSpanAttributesByTraceID(traceID string) (int64, error)
	DeleteSpanAttributesByGroupID(groupID string) (int64, error)

	GetTraceGroups(limit int, before time.Time) ([]TraceGroup, error)
	GetTraceGroupSpans(traceID string, limit int) ([]Span, error)
	GetTraceGroupsWithSearch(limit int, before time.Time, search string) ([]TraceGroup, error)
	GetTraceGroupSpansWithSearch(traceID string, limit int, search string) ([]Span, error)

	BatchUpsertConversations(updates []ConversationUpdate) error
	GetConversations(limit int, before time.Time) ([]Conversation, error)
	GetConversationsWithSearch(limit int, before time.Time, search string) ([]Conversation, error)
	PropagateConversationID(traceID, conversationID string) (int64, error)
	DeleteSpansByConversationID(conversationID string) (int64, error)
	DeleteSpanAttributesByConversationID(conversationID string) (int64, error)
	DeleteConversationRow(conversationID string) (int64, error)
	LookupConversationIDByTraceID(traceID string) (string, error)

	BatchInsertSpanLinks(links []SpanLink) error
	GetLinkedConversations(conversationID string) ([]string, error)
	BackfillDerived(limit int) (int, int, error)

	GetProjects() ([]Project, error)
	GetProjectByID(id string) (*Project, error)
	CreateProject(id, name string) error
	EnsureDefaultProject() error

	Close() error
}

// InitDatabase initializes the database connection using GORM
func InitDatabase(config *Config) (Database, error) {
	var gormDB *gorm.DB
	var err error

	// Configure GORM logger
	gormLogger := logger.Default.LogMode(logger.Silent)
	if config.LogLevel == "DEBUG" {
		gormLogger = logger.Default.LogMode(logger.Info)
	}

	if config.DBType == "postgres" {
		gormDB, err = gorm.Open(postgres.Open(config.DBConnection), &gorm.Config{
			Logger: gormLogger,
		})
	} else {
		// SQLite - ensure directory exists
		if config.DBConnection != ":memory:" {
			dir := filepath.Dir(config.DBConnection)
			if err := os.MkdirAll(dir, 0755); err != nil {
				return nil, fmt.Errorf("failed to create database directory: %w", err)
			}
		}
		gormDB, err = gorm.Open(sqlite.Open(config.DBConnection), &gorm.Config{
			Logger: gormLogger,
		})
	}

	if err != nil {
		return nil, fmt.Errorf("failed to connect database: %w", err)
	}

	// Auto-migrate all models
	if err := gormDB.AutoMigrate(
		&Trace{},
		&Span{},
		&SpanAttribute{},
		&Conversation{},
		&Project{},
		&SpanLink{},
	); err != nil {
		return nil, fmt.Errorf("failed to migrate database: %w", err)
	}

	db := &GormDB{db: gormDB}

	// Ensure default project exists
	if err := db.EnsureDefaultProject(); err != nil {
		return nil, fmt.Errorf("failed to ensure default project: %w", err)
	}

	return db, nil
}

// Close closes the database connection
func (g *GormDB) Close() error {
	sqlDB, err := g.db.DB()
	if err != nil {
		return err
	}
	return sqlDB.Close()
}

// Trace operations
func (g *GormDB) CreateTrace(trace Trace) (string, error) {
	if trace.ID == "" {
		trace.ID = generateID()
	}
	if err := g.db.Create(&trace).Error; err != nil {
		return "", err
	}
	return trace.ID, nil
}

func (g *GormDB) GetTraces() ([]Trace, error) {
	return g.GetTracesPaginated(100, time.Time{})
}

func (g *GormDB) GetTracesPaginated(limit int, before time.Time) ([]Trace, error) {
	if limit <= 0 || limit > 1000 {
		limit = 100
	}

	var traces []Trace
	query := g.db.Order("timestamp DESC").Limit(limit)

	if !before.IsZero() {
		query = query.Where("timestamp < ?", before)
	}

	if err := query.Find(&traces).Error; err != nil {
		return nil, err
	}

	return traces, nil
}

func (g *GormDB) GetTraceByID(id string) (*Trace, error) {
	var trace Trace
	if err := g.db.First(&trace, "id = ?", id).Error; err != nil {
		return nil, err
	}
	return &trace, nil
}

func (g *GormDB) DeleteTrace(id string) error {
	return g.db.Delete(&Trace{}, "id = ?", id).Error
}

// Span operations
func (g *GormDB) BatchInsertSpans(spans []Span) error {
	if len(spans) == 0 {
		return nil
	}
	return g.db.CreateInBatches(spans, 100).Error
}

func (g *GormDB) GetSpans(limit int, before time.Time) ([]Span, error) {
	if limit <= 0 || limit > 5000 {
		limit = 1000
	}

	var spans []Span
	query := g.db.Order("start_time DESC").Limit(limit)

	if !before.IsZero() {
		query = query.Where("start_time < ?", before)
	}

	if err := query.Find(&spans).Error; err != nil {
		return nil, err
	}

	return spans, nil
}

func (g *GormDB) DeleteSpansByTraceID(traceID string) (int64, error) {
	result := g.db.Where("trace_id = ?", traceID).Delete(&Span{})
	return result.RowsAffected, result.Error
}

func (g *GormDB) DeleteSpansByGroupID(groupID string) (int64, error) {
	// For SQLite, group_id is trace_id or attribute st.conversation
	result := g.db.Where("trace_id = ?", groupID).Delete(&Span{})
	return result.RowsAffected, result.Error
}

// SpanAttribute operations
func (g *GormDB) BatchUpsertSpanAttributes(attrs []SpanAttribute) error {
	if len(attrs) == 0 {
		return nil
	}

	// Delete existing attributes for these spans first
	spanIDs := make([]string, 0, len(attrs))
	seen := make(map[string]bool)
	for _, attr := range attrs {
		if !seen[attr.SpanID] {
			spanIDs = append(spanIDs, attr.SpanID)
			seen[attr.SpanID] = true
		}
	}

	if err := g.db.Where("span_id IN ?", spanIDs).Delete(&SpanAttribute{}).Error; err != nil {
		return err
	}

	// Insert new attributes
	return g.db.CreateInBatches(attrs, 100).Error
}

func (g *GormDB) DeleteSpanAttributesByTraceID(traceID string) (int64, error) {
	result := g.db.Where("trace_id = ?", traceID).Delete(&SpanAttribute{})
	return result.RowsAffected, result.Error
}

func (g *GormDB) DeleteSpanAttributesByGroupID(groupID string) (int64, error) {
	result := g.db.Where("trace_id = ?", groupID).Delete(&SpanAttribute{})
	return result.RowsAffected, result.Error
}

// TraceGroup operations
func (g *GormDB) GetTraceGroups(limit int, before time.Time) ([]TraceGroup, error) {
	if limit <= 0 || limit > 1000 {
		limit = 100
	}

	type groupResult struct {
		TraceID        string
		FirstStartTime time.Time
		LastEndTime    time.Time
		SpanCount      int
	}

	var results []groupResult
	query := g.db.Model(&Span{}).
		Select("trace_id, MIN(start_time) as first_start_time, MAX(end_time) as last_end_time, COUNT(*) as span_count").
		Group("trace_id").
		Order("MAX(end_time) DESC").
		Limit(limit)

	if !before.IsZero() {
		query = query.Having("MAX(end_time) < ?", before)
	}

	if err := query.Scan(&results).Error; err != nil {
		return nil, err
	}

	// Extract models
	groups := make([]TraceGroup, len(results))
	for i, r := range results {
		groups[i] = TraceGroup{
			TraceID:        r.TraceID,
			FirstStartTime: r.FirstStartTime,
			LastEndTime:    r.LastEndTime,
			SpanCount:      r.SpanCount,
		}

		// Get model from latest span
		var span Span
		if err := g.db.Where("trace_id = ?", r.TraceID).
			Order("start_time DESC").
			First(&span).Error; err == nil {
			groups[i].Model = extractModelFromAttrJSON(span.Attributes)
		}
	}

	return groups, nil
}

func (g *GormDB) GetTraceGroupSpans(traceID string, limit int) ([]Span, error) {
	if limit <= 0 || limit > 5000 {
		limit = 1000
	}

	var spans []Span
	if err := g.db.Where("trace_id = ?", traceID).
		Order("start_time ASC, span_id ASC").
		Limit(limit).
		Find(&spans).Error; err != nil {
		return nil, err
	}

	return spans, nil
}

func (g *GormDB) GetTraceGroupsWithSearch(limit int, before time.Time, search string) ([]TraceGroup, error) {
	if limit <= 0 || limit > 1000 {
		limit = 100
	}

	pattern := "%" + strings.ToLower(strings.TrimSpace(search)) + "%"

	type groupResult struct {
		TraceID        string
		FirstStartTime time.Time
		LastEndTime    time.Time
		SpanCount      int
	}

	var results []groupResult
	query := g.db.Model(&Span{}).
		Select("trace_id, MIN(start_time) as first_start_time, MAX(end_time) as last_end_time, COUNT(*) as span_count").
		Where("LOWER(name) LIKE ? OR LOWER(span_id) LIKE ? OR LOWER(status_code) LIKE ? OR LOWER(status_description) LIKE ? OR LOWER(attributes) LIKE ? OR LOWER(events) LIKE ?",
			pattern, pattern, pattern, pattern, pattern, pattern).
		Group("trace_id").
		Order("MAX(end_time) DESC").
		Limit(limit)

	if !before.IsZero() {
		query = query.Having("MAX(end_time) < ?", before)
	}

	if err := query.Scan(&results).Error; err != nil {
		return nil, err
	}

	groups := make([]TraceGroup, len(results))
	for i, r := range results {
		groups[i] = TraceGroup{
			TraceID:        r.TraceID,
			FirstStartTime: r.FirstStartTime,
			LastEndTime:    r.LastEndTime,
			SpanCount:      r.SpanCount,
		}

		var span Span
		if err := g.db.Where("trace_id = ?", r.TraceID).
			Order("start_time DESC").
			First(&span).Error; err == nil {
			groups[i].Model = extractModelFromAttrJSON(span.Attributes)
		}
	}

	return groups, nil
}

func (g *GormDB) GetTraceGroupSpansWithSearch(traceID string, limit int, search string) ([]Span, error) {
	if limit <= 0 || limit > 5000 {
		limit = 1000
	}

	pattern := "%" + strings.ToLower(strings.TrimSpace(search)) + "%"

	var spans []Span
	if err := g.db.Where("trace_id = ?", traceID).
		Where("LOWER(name) LIKE ? OR LOWER(span_id) LIKE ? OR LOWER(status_code) LIKE ? OR LOWER(status_description) LIKE ? OR LOWER(attributes) LIKE ? OR LOWER(events) LIKE ?",
			pattern, pattern, pattern, pattern, pattern, pattern).
		Order("start_time ASC, span_id ASC").
		Limit(limit).
		Find(&spans).Error; err != nil {
		return nil, err
	}

	return spans, nil
}

// Conversation operations
func (g *GormDB) BatchUpsertConversations(updates []ConversationUpdate) error {
	if len(updates) == 0 {
		return nil
	}

	for _, u := range updates {
		var conv Conversation
		err := g.db.Where("id = ?", u.ID).First(&conv).Error

		if err == gorm.ErrRecordNotFound {
			// Create new conversation
			conv = Conversation{
				ID:             u.ID,
				ProjectID:      u.ProjectID,
				FirstStartTime: u.Start,
				LastEndTime:    u.End,
				SpanCount:      u.Count,
				Model:          u.Model,
			}
			if conv.ProjectID == "" {
				conv.ProjectID = "default"
			}
			if err := g.db.Create(&conv).Error; err != nil {
				return err
			}
		} else if err != nil {
			return err
		} else {
			// Update existing conversation
			updates := map[string]interface{}{
				"last_end_time": u.End,
				"span_count":    gorm.Expr("span_count + ?", u.Count),
			}
			if u.Start.Before(conv.FirstStartTime) {
				updates["first_start_time"] = u.Start
			}
			if u.Model != "" && conv.Model == "" {
				updates["model"] = u.Model
			}
			if err := g.db.Model(&conv).Updates(updates).Error; err != nil {
				return err
			}
		}
	}

	return nil
}

func (g *GormDB) GetConversations(limit int, before time.Time) ([]Conversation, error) {
	if limit <= 0 || limit > 1000 {
		limit = 100
	}

	var conversations []Conversation
	query := g.db.Order("last_end_time DESC").Limit(limit)

	if !before.IsZero() {
		query = query.Where("last_end_time < ?", before)
	}

	if err := query.Find(&conversations).Error; err != nil {
		return nil, err
	}

	return conversations, nil
}

func (g *GormDB) GetConversationsWithSearch(limit int, before time.Time, search string) ([]Conversation, error) {
	if limit <= 0 || limit > 1000 {
		limit = 100
	}

	pattern := "%" + strings.ToLower(strings.TrimSpace(search)) + "%"

	var conversations []Conversation
	query := g.db.Where("LOWER(id) LIKE ? OR LOWER(model) LIKE ?", pattern, pattern).
		Order("last_end_time DESC").
		Limit(limit)

	if !before.IsZero() {
		query = query.Where("last_end_time < ?", before)
	}

	if err := query.Find(&conversations).Error; err != nil {
		return nil, err
	}

	return conversations, nil
}

func (g *GormDB) PropagateConversationID(traceID, conversationID string) (int64, error) {
	// Find all spans with this trace_id
	var spans []Span
	if err := g.db.Where("trace_id = ?", traceID).Find(&spans).Error; err != nil {
		return 0, err
	}

	var updated int64
	for _, span := range spans {
		// Parse attributes
		var attrs map[string]interface{}
		if span.Attributes != "" {
			if err := json.Unmarshal([]byte(span.Attributes), &attrs); err != nil {
				continue
			}
		} else {
			attrs = make(map[string]interface{})
		}

		// Add conversation ID
		attrs["st.conversation"] = conversationID

		// Marshal back
		attrsJSON, err := json.Marshal(attrs)
		if err != nil {
			continue
		}

		// Update span
		if err := g.db.Model(&span).Update("attributes", string(attrsJSON)).Error; err != nil {
			continue
		}

		// Also update span_attributes table
		convAttr := SpanAttribute{
			SpanID:    span.SpanID,
			TraceID:   span.TraceID,
			Key:       "st.conversation",
			Type:      "string",
			StringVal: &conversationID,
		}
		g.db.Where("span_id = ? AND key = ?", span.SpanID, "st.conversation").Delete(&SpanAttribute{})
		g.db.Create(&convAttr)

		updated++
	}

	return updated, nil
}

func (g *GormDB) DeleteSpansByConversationID(conversationID string) (int64, error) {
	// Find spans with st.conversation attribute
	var attrs []SpanAttribute
	if err := g.db.Where("key = ? AND string_val = ?", "st.conversation", conversationID).
		Find(&attrs).Error; err != nil {
		return 0, err
	}

	if len(attrs) == 0 {
		return 0, nil
	}

	spanIDs := make([]string, len(attrs))
	for i, attr := range attrs {
		spanIDs[i] = attr.SpanID
	}

	result := g.db.Where("span_id IN ?", spanIDs).Delete(&Span{})
	return result.RowsAffected, result.Error
}

func (g *GormDB) DeleteSpanAttributesByConversationID(conversationID string) (int64, error) {
	var attrs []SpanAttribute
	if err := g.db.Where("key = ? AND string_val = ?", "st.conversation", conversationID).
		Find(&attrs).Error; err != nil {
		return 0, err
	}

	if len(attrs) == 0 {
		return 0, nil
	}

	spanIDs := make([]string, len(attrs))
	for i, attr := range attrs {
		spanIDs[i] = attr.SpanID
	}

	result := g.db.Where("span_id IN ?", spanIDs).Delete(&SpanAttribute{})
	return result.RowsAffected, result.Error
}

func (g *GormDB) DeleteConversationRow(conversationID string) (int64, error) {
	result := g.db.Delete(&Conversation{}, "id = ?", conversationID)
	return result.RowsAffected, result.Error
}

func (g *GormDB) LookupConversationIDByTraceID(traceID string) (string, error) {
	var attr SpanAttribute
	err := g.db.Where("trace_id = ? AND key = ?", traceID, "st.conversation").
		First(&attr).Error

	if err == gorm.ErrRecordNotFound {
		return "", nil
	}
	if err != nil {
		return "", err
	}

	if attr.StringVal != nil {
		return *attr.StringVal, nil
	}

	return "", nil
}

// SpanLink operations
func (g *GormDB) BatchInsertSpanLinks(links []SpanLink) error {
	if len(links) == 0 {
		return nil
	}
	return g.db.CreateInBatches(links, 100).Error
}

func (g *GormDB) GetLinkedConversations(conversationID string) ([]string, error) {
	// Find all spans in this conversation
	var attrs []SpanAttribute
	if err := g.db.Where("key = ? AND string_val = ?", "st.conversation", conversationID).
		Find(&attrs).Error; err != nil {
		return nil, err
	}

	if len(attrs) == 0 {
		return []string{}, nil
	}

	spanIDs := make([]string, len(attrs))
	for i, attr := range attrs {
		spanIDs[i] = attr.SpanID
	}

	// Find linked spans
	var links []SpanLink
	if err := g.db.Where("span_id IN ?", spanIDs).Find(&links).Error; err != nil {
		return nil, err
	}

	// Get conversation IDs for linked traces
	linkedTraceIDs := make([]string, 0)
	for _, link := range links {
		linkedTraceIDs = append(linkedTraceIDs, link.LinkedTraceID)
	}

	if len(linkedTraceIDs) == 0 {
		return []string{}, nil
	}

	var linkedAttrs []SpanAttribute
	if err := g.db.Where("trace_id IN ? AND key = ?", linkedTraceIDs, "st.conversation").
		Distinct("string_val").
		Find(&linkedAttrs).Error; err != nil {
		return nil, err
	}

	result := make([]string, 0)
	for _, attr := range linkedAttrs {
		if attr.StringVal != nil && *attr.StringVal != conversationID {
			result = append(result, *attr.StringVal)
		}
	}

	return result, nil
}

// BackfillDerived computes and stores derived attributes
func (g *GormDB) BackfillDerived(limit int) (int, int, error) {
	if limit <= 0 {
		limit = 100
	}

	// Find spans without st.model or st.category
	var spans []Span
	if err := g.db.Where("attributes NOT LIKE ?", "%st.model%").
		Or("attributes NOT LIKE ?", "%st.category%").
		Limit(limit).
		Find(&spans).Error; err != nil {
		return 0, 0, err
	}

	updatedSpans := 0
	upsertedAttrs := 0

	for _, span := range spans {
		var attrs map[string]interface{}
		if span.Attributes != "" {
			if err := json.Unmarshal([]byte(span.Attributes), &attrs); err != nil {
				continue
			}
		} else {
			attrs = make(map[string]interface{})
		}

		modified := false

		// Derive model
		if _, exists := attrs["st.model"]; !exists {
			if model := extractModelFromAttrJSON(span.Attributes); model != "" {
				attrs["st.model"] = model
				modified = true

				modelAttr := SpanAttribute{
					SpanID:    span.SpanID,
					TraceID:   span.TraceID,
					Key:       "st.model",
					Type:      "string",
					StringVal: &model,
				}
				g.db.Where("span_id = ? AND key = ?", span.SpanID, "st.model").Delete(&SpanAttribute{})
				g.db.Create(&modelAttr)
				upsertedAttrs++
			}
		}

		// Derive category
		if _, exists := attrs["st.category"]; !exists {
			category := "other"
			if strings.Contains(strings.ToLower(span.Name), "llm") {
				category = "llm"
			} else if strings.Contains(strings.ToLower(span.Name), "tool") {
				category = "tool"
			}
			attrs["st.category"] = category
			modified = true

			catAttr := SpanAttribute{
				SpanID:    span.SpanID,
				TraceID:   span.TraceID,
				Key:       "st.category",
				Type:      "string",
				StringVal: &category,
			}
			g.db.Where("span_id = ? AND key = ?", span.SpanID, "st.category").Delete(&SpanAttribute{})
			g.db.Create(&catAttr)
			upsertedAttrs++
		}

		if modified {
			attrsJSON, _ := json.Marshal(attrs)
			g.db.Model(&span).Update("attributes", string(attrsJSON))
			updatedSpans++
		}
	}

	return updatedSpans, upsertedAttrs, nil
}

// Project operations
func (g *GormDB) GetProjects() ([]Project, error) {
	var projects []Project
	if err := g.db.Order("name ASC").Find(&projects).Error; err != nil {
		return nil, err
	}
	return projects, nil
}

func (g *GormDB) GetProjectByID(id string) (*Project, error) {
	var project Project
	if err := g.db.First(&project, "id = ?", id).Error; err != nil {
		return nil, err
	}
	return &project, nil
}

func (g *GormDB) CreateProject(id, name string) error {
	project := Project{
		ID:   id,
		Name: name,
	}
	return g.db.Create(&project).Error
}

func (g *GormDB) EnsureDefaultProject() error {
	var project Project
	err := g.db.Where("id = ?", "default").First(&project).Error

	if err == gorm.ErrRecordNotFound {
		project = Project{
			ID:   "default",
			Name: "Default Project",
		}
		return g.db.Create(&project).Error
	}

	return err
}

// Helper function to extract model from attributes JSON
func extractModelFromAttrJSON(attrJSON string) string {
	if attrJSON == "" {
		return ""
	}

	var attrs map[string]interface{}
	if err := json.Unmarshal([]byte(attrJSON), &attrs); err != nil {
		return ""
	}

	// Try different model keys
	modelKeys := []string{"gen_ai.request.model", "model", "llm.model", "st.model"}
	for _, key := range modelKeys {
		if val, ok := attrs[key]; ok {
			if str, ok := val.(string); ok && str != "" {
				return str
			}
		}
	}

	return ""
}

// generateID generates a unique ID for traces
func generateID() string {
	return fmt.Sprintf("%d", time.Now().UnixNano())
}
