// Generated by Copilot
package backend

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"gorm.io/driver/postgres"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

// GORM Models with proper tags
type Span struct {
	SpanID       string    `gorm:"primaryKey" json:"span_id"`
	TraceID      string    `gorm:"index:idx_trace_id;index:idx_group_id" json:"trace_id"`
	ProjectID    string    `gorm:"index" json:"project_id"`
	ParentSpanID string    `json:"parent_span_id,omitempty"`
	Name         string    `json:"name"`
	StartTime    time.Time `gorm:"index:idx_start_time" json:"start_time"`
	EndTime      time.Time `json:"end_time"`
	DurationMS   int64     `json:"duration_ms"`
	StatusCode   string    `json:"status_code"`
	StatusDesc   string    `json:"status_description,omitempty"`
	Attributes   string    `gorm:"type:text" json:"attributes,omitempty"`
	Events       string    `gorm:"type:text" json:"events,omitempty"`
}

type Conversation struct {
	ID             string    `gorm:"primaryKey" json:"id"`
	ProjectID      string    `gorm:"index;default:'default'" json:"project_id"`
	UserID         string    `gorm:"index" json:"user_id,omitempty"`
	FirstStartTime time.Time `json:"first_start_time"`
	LastEndTime    time.Time `gorm:"index" json:"last_end_time"`
}

type Project struct {
	ID        string    `gorm:"primaryKey" json:"id"`
	Name      string    `gorm:"not null" json:"name"`
	CreatedAt time.Time `gorm:"autoCreateTime" json:"created_at"`
	UpdatedAt time.Time `gorm:"autoUpdateTime" json:"updated_at"`
}

// Helper structs
type TraceGroup struct {
	TraceID        string    `json:"trace_id"`
	FirstStartTime time.Time `json:"first_start_time"`
	LastEndTime    time.Time `json:"last_end_time"`
	SpanCount      int       `json:"span_count"`
}

type ConversationUpdate struct {
	ID        string
	ProjectID string
	UserID    string
	Start     time.Time
	End       time.Time
}

// GormDB implements the Database interface using GORM
type GormDB struct {
	db *gorm.DB
}

// Database interface
type Database interface {
	BatchInsertSpans(spans []Span) error
	GetSpans(limit int, before time.Time) ([]Span, error)
	DeleteSpansByTraceID(traceID string) (int64, error)
	DeleteSpansByGroupID(groupID string) (int64, error)

	GetTraceGroups(limit int, before time.Time) ([]TraceGroup, error)
	GetTraceGroupSpans(traceID string, limit int) ([]Span, error)
	GetTraceGroupsWithSearch(limit int, before time.Time, search string) ([]TraceGroup, error)
	GetTraceGroupSpansWithSearch(traceID string, limit int, search string) ([]Span, error)

	BatchUpsertConversations(updates []ConversationUpdate) error
	GetConversations(limit int, before time.Time) ([]Conversation, error)
	GetConversationsWithSearch(limit int, before time.Time, search string) ([]Conversation, error)
	PropagateConversationID(traceID, conversationID string) (int64, error)
	DeleteSpansByConversationID(conversationID string) (int64, error)
	DeleteConversationRow(conversationID string) (int64, error)
	LookupConversationIDByTraceID(traceID string) (string, error)

	BackfillDerived(limit int) (int, int, error)

	GetProjects() ([]Project, error)
	GetProjectByID(id string) (*Project, error)
	CreateProject(id, name string) error
	EnsureDefaultProject() error

	Close() error
}

// InitDatabase initializes the database connection using GORM
func InitDatabase(config *Config) (Database, error) {
	var gormDB *gorm.DB
	var err error

	// Configure GORM logger
	gormLogger := logger.Default.LogMode(logger.Silent)
	if config.LogLevel == "DEBUG" {
		gormLogger = logger.Default.LogMode(logger.Info)
	}

	if config.DBType == "postgres" {
		gormDB, err = gorm.Open(postgres.Open(config.DBConnection), &gorm.Config{
			Logger: gormLogger,
		})
	} else {
		// SQLite - ensure directory exists
		if config.DBConnection != ":memory:" {
			dir := filepath.Dir(config.DBConnection)
			if err := os.MkdirAll(dir, 0755); err != nil {
				return nil, fmt.Errorf("failed to create database directory: %w", err)
			}
		}
		gormDB, err = gorm.Open(sqlite.Open(config.DBConnection), &gorm.Config{
			Logger: gormLogger,
		})
	}

	if err != nil {
		return nil, fmt.Errorf("failed to connect database: %w", err)
	}

	// Auto-migrate all models
	if err := gormDB.AutoMigrate(
		&Span{},
		&Conversation{},
		&Project{},
	); err != nil {
		return nil, fmt.Errorf("failed to migrate database: %w", err)
	}

	db := &GormDB{db: gormDB}

	// Ensure default project exists
	if err := db.EnsureDefaultProject(); err != nil {
		return nil, fmt.Errorf("failed to ensure default project: %w", err)
	}

	return db, nil
}

// Close closes the database connection
func (g *GormDB) Close() error {
	sqlDB, err := g.db.DB()
	if err != nil {
		return err
	}
	return sqlDB.Close()
}

// Span operations
func (g *GormDB) BatchInsertSpans(spans []Span) error {
	if len(spans) == 0 {
		return nil
	}
	return g.db.CreateInBatches(spans, 100).Error
}

func (g *GormDB) GetSpans(limit int, before time.Time) ([]Span, error) {
	if limit <= 0 || limit > 5000 {
		limit = 1000
	}

	var spans []Span
	query := g.db.Order("start_time DESC").Limit(limit)

	if !before.IsZero() {
		query = query.Where("start_time < ?", before)
	}

	if err := query.Find(&spans).Error; err != nil {
		return nil, err
	}

	return spans, nil
}

func (g *GormDB) DeleteSpansByTraceID(traceID string) (int64, error) {
	result := g.db.Where("trace_id = ?", traceID).Delete(&Span{})
	return result.RowsAffected, result.Error
}

func (g *GormDB) DeleteSpansByGroupID(groupID string) (int64, error) {
	// For SQLite, group_id is trace_id or attribute simpleTraces.conversation.id
	result := g.db.Where("trace_id = ?", groupID).Delete(&Span{})
	return result.RowsAffected, result.Error
}

// TraceGroup operations
func (g *GormDB) GetTraceGroups(limit int, before time.Time) ([]TraceGroup, error) {
	if limit <= 0 || limit > 1000 {
		limit = 100
	}

	type groupResult struct {
		TraceID        string
		FirstStartTime time.Time
		LastEndTime    time.Time
		SpanCount      int
	}

	var results []groupResult
	query := g.db.Model(&Span{}).
		Select("trace_id, MIN(start_time) as first_start_time, MAX(end_time) as last_end_time, COUNT(*) as span_count").
		Group("trace_id").
		Order("MAX(end_time) DESC").
		Limit(limit)

	if !before.IsZero() {
		query = query.Having("MAX(end_time) < ?", before)
	}

	if err := query.Scan(&results).Error; err != nil {
		return nil, err
	}

	groups := make([]TraceGroup, len(results))
	for i, r := range results {
		groups[i] = TraceGroup{
			TraceID:        r.TraceID,
			FirstStartTime: r.FirstStartTime,
			LastEndTime:    r.LastEndTime,
			SpanCount:      r.SpanCount,
		}
	}

	return groups, nil
}

func (g *GormDB) GetTraceGroupSpans(traceID string, limit int) ([]Span, error) {
	if limit <= 0 || limit > 5000 {
		limit = 1000
	}

	var spans []Span
	if err := g.db.Where("trace_id = ?", traceID).
		Order("start_time ASC, span_id ASC").
		Limit(limit).
		Find(&spans).Error; err != nil {
		return nil, err
	}

	return spans, nil
}

func (g *GormDB) GetTraceGroupsWithSearch(limit int, before time.Time, search string) ([]TraceGroup, error) {
	if limit <= 0 || limit > 1000 {
		limit = 100
	}

	pattern := "%" + strings.ToLower(strings.TrimSpace(search)) + "%"

	type groupResult struct {
		TraceID        string
		FirstStartTime time.Time
		LastEndTime    time.Time
		SpanCount      int
	}

	var results []groupResult
	query := g.db.Model(&Span{}).
		Select("trace_id, MIN(start_time) as first_start_time, MAX(end_time) as last_end_time, COUNT(*) as span_count").
		Where("LOWER(name) LIKE ? OR LOWER(span_id) LIKE ? OR LOWER(status_code) LIKE ? OR LOWER(status_description) LIKE ? OR LOWER(attributes) LIKE ? OR LOWER(events) LIKE ?",
			pattern, pattern, pattern, pattern, pattern, pattern).
		Group("trace_id").
		Order("MAX(end_time) DESC").
		Limit(limit)

	if !before.IsZero() {
		query = query.Having("MAX(end_time) < ?", before)
	}

	if err := query.Scan(&results).Error; err != nil {
		return nil, err
	}

	groups := make([]TraceGroup, len(results))
	for i, r := range results {
		groups[i] = TraceGroup{
			TraceID:        r.TraceID,
			FirstStartTime: r.FirstStartTime,
			LastEndTime:    r.LastEndTime,
			SpanCount:      r.SpanCount,
		}
	}

	return groups, nil
}

func (g *GormDB) GetTraceGroupSpansWithSearch(traceID string, limit int, search string) ([]Span, error) {
	if limit <= 0 || limit > 5000 {
		limit = 1000
	}

	pattern := "%" + strings.ToLower(strings.TrimSpace(search)) + "%"

	var spans []Span
	if err := g.db.Where("trace_id = ?", traceID).
		Where("LOWER(name) LIKE ? OR LOWER(span_id) LIKE ? OR LOWER(status_code) LIKE ? OR LOWER(status_description) LIKE ? OR LOWER(attributes) LIKE ? OR LOWER(events) LIKE ?",
			pattern, pattern, pattern, pattern, pattern, pattern).
		Order("start_time ASC, span_id ASC").
		Limit(limit).
		Find(&spans).Error; err != nil {
		return nil, err
	}

	return spans, nil
}

// Conversation operations
func (g *GormDB) BatchUpsertConversations(updates []ConversationUpdate) error {
	if len(updates) == 0 {
		return nil
	}

	for _, u := range updates {
		var conv Conversation
		err := g.db.Where("id = ?", u.ID).First(&conv).Error

		if err == gorm.ErrRecordNotFound {
			// Create new conversation
			conv = Conversation{
				ID:             u.ID,
				ProjectID:      u.ProjectID,
				UserID:         u.UserID,
				FirstStartTime: u.Start,
				LastEndTime:    u.End,
			}
			if conv.ProjectID == "" {
				conv.ProjectID = "default"
			}
			if err := g.db.Create(&conv).Error; err != nil {
				return err
			}
		} else if err != nil {
			return err
		} else {
			// Update existing conversation
			updateFields := map[string]interface{}{
				"last_end_time": u.End,
			}
			if u.Start.Before(conv.FirstStartTime) {
				updateFields["first_start_time"] = u.Start
			}
			if u.UserID != "" && conv.UserID == "" {
				updateFields["user_id"] = u.UserID
			}
			if err := g.db.Model(&conv).Updates(updateFields).Error; err != nil {
				return err
			}
		}
	}

	return nil
}

func (g *GormDB) GetConversations(limit int, before time.Time) ([]Conversation, error) {
	if limit <= 0 || limit > 1000 {
		limit = 100
	}

	var conversations []Conversation
	query := g.db.Order("last_end_time DESC").Limit(limit)

	if !before.IsZero() {
		query = query.Where("last_end_time < ?", before)
	}

	if err := query.Find(&conversations).Error; err != nil {
		return nil, err
	}

	return conversations, nil
}

func (g *GormDB) GetConversationsWithSearch(limit int, before time.Time, search string) ([]Conversation, error) {
	if limit <= 0 || limit > 1000 {
		limit = 100
	}

	pattern := "%" + strings.ToLower(strings.TrimSpace(search)) + "%"

	var conversations []Conversation
	query := g.db.Where("LOWER(id) LIKE ? OR LOWER(model) LIKE ?", pattern, pattern).
		Order("last_end_time DESC").
		Limit(limit)

	if !before.IsZero() {
		query = query.Where("last_end_time < ?", before)
	}

	if err := query.Find(&conversations).Error; err != nil {
		return nil, err
	}

	return conversations, nil
}

func (g *GormDB) PropagateConversationID(traceID, conversationID string) (int64, error) {
	// Find all spans with this trace_id
	var spans []Span
	if err := g.db.Where("trace_id = ?", traceID).Find(&spans).Error; err != nil {
		return 0, err
	}

	var updated int64
	for _, span := range spans {
		// Parse attributes
		var attrs map[string]interface{}
		if span.Attributes != "" {
			if err := json.Unmarshal([]byte(span.Attributes), &attrs); err != nil {
				continue
			}
		} else {
			attrs = make(map[string]interface{})
		}

		// Add conversation ID
		attrs["simpleTraces.conversation.id"] = conversationID

		// Marshal back
		attrsJSON, err := json.Marshal(attrs)
		if err != nil {
			continue
		}

		// Update span
		if err := g.db.Model(&span).Update("attributes", string(attrsJSON)).Error; err != nil {
			continue
		}

		updated++
	}

	return updated, nil
}

func (g *GormDB) DeleteSpansByConversationID(conversationID string) (int64, error) {
	// Find spans with simpleTraces.conversation.id attribute in JSON
	var spans []Span
	if err := g.db.Where("attributes LIKE ?", "%\"simpleTraces.conversation.id\":\""+conversationID+"\"%").
		Find(&spans).Error; err != nil {
		return 0, err
	}

	if len(spans) == 0 {
		return 0, nil
	}

	spanIDs := make([]string, len(spans))
	for i, span := range spans {
		spanIDs[i] = span.SpanID
	}

	result := g.db.Where("span_id IN ?", spanIDs).Delete(&Span{})
	return result.RowsAffected, result.Error
}

func (g *GormDB) DeleteConversationRow(conversationID string) (int64, error) {
	result := g.db.Delete(&Conversation{}, "id = ?", conversationID)
	return result.RowsAffected, result.Error
}

func (g *GormDB) LookupConversationIDByTraceID(traceID string) (string, error) {
	// Look for simpleTraces.conversation.id in attributes JSON
	var span Span
	err := g.db.Where("trace_id = ?", traceID).
		Where("attributes LIKE ?", "%\"simpleTraces.conversation.id\":%").
		First(&span).Error

	if err == gorm.ErrRecordNotFound {
		return "", nil
	}
	if err != nil {
		return "", err
	}

	// Parse attributes to extract conversation ID
	var attrs map[string]interface{}
	if err := json.Unmarshal([]byte(span.Attributes), &attrs); err != nil {
		return "", nil
	}

	if convID, ok := attrs["simpleTraces.conversation.id"].(string); ok {
		return convID, nil
	}

	return "", nil
}

// BackfillDerived computes and stores derived attributes
func (g *GormDB) BackfillDerived(limit int) (int, int, error) {
	if limit <= 0 {
		limit = 100
	}

	// Find spans without simpleTraces.model or simpleTraces.category
	var spans []Span
	if err := g.db.Where("attributes NOT LIKE ?", "%simpleTraces.model%").
		Or("attributes NOT LIKE ?", "%simpleTraces.category%").
		Limit(limit).
		Find(&spans).Error; err != nil {
		return 0, 0, err
	}

	updatedSpans := 0

	for _, span := range spans {
		var attrs map[string]interface{}
		if span.Attributes != "" {
			if err := json.Unmarshal([]byte(span.Attributes), &attrs); err != nil {
				continue
			}
		} else {
			attrs = make(map[string]interface{})
		}

		modified := false

		// Derive model
		if _, exists := attrs["simpleTraces.model"]; !exists {
			if model := extractModelFromAttrJSON(span.Attributes); model != "" {
				attrs["simpleTraces.model"] = model
				modified = true
			}
		}

		// Derive category
		if _, exists := attrs["simpleTraces.category"]; !exists {
			category := "other"
			if strings.Contains(strings.ToLower(span.Name), "llm") {
				category = "llm"
			} else if strings.Contains(strings.ToLower(span.Name), "tool") {
				category = "tool"
			}
			attrs["simpleTraces.category"] = category
			modified = true
		}

		if modified {
			attrsJSON, _ := json.Marshal(attrs)
			g.db.Model(&span).Update("attributes", string(attrsJSON))
			updatedSpans++
		}
	}

	return updatedSpans, 0, nil
}

// Project operations
func (g *GormDB) GetProjects() ([]Project, error) {
	var projects []Project
	if err := g.db.Order("name ASC").Find(&projects).Error; err != nil {
		return nil, err
	}
	return projects, nil
}

func (g *GormDB) GetProjectByID(id string) (*Project, error) {
	var project Project
	if err := g.db.First(&project, "id = ?", id).Error; err != nil {
		return nil, err
	}
	return &project, nil
}

func (g *GormDB) CreateProject(id, name string) error {
	project := Project{
		ID:   id,
		Name: name,
	}
	return g.db.Create(&project).Error
}

func (g *GormDB) EnsureDefaultProject() error {
	var project Project
	err := g.db.Where("id = ?", "default").First(&project).Error

	if err == gorm.ErrRecordNotFound {
		project = Project{
			ID:   "default",
			Name: "Default Project",
		}
		return g.db.Create(&project).Error
	}

	return err
}

// Helper function to extract model from attributes JSON
func extractModelFromAttrJSON(attrJSON string) string {
	if attrJSON == "" {
		return ""
	}

	var attrs map[string]interface{}
	if err := json.Unmarshal([]byte(attrJSON), &attrs); err != nil {
		return ""
	}

	// Try different model keys
	modelKeys := []string{"gen_ai.request.model", "model", "llm.model", "simpleTraces.model"}
	for _, key := range modelKeys {
		if val, ok := attrs[key]; ok {
			if str, ok := val.(string); ok && str != "" {
				return str
			}
		}
	}

	return ""
}

// generateID generates a unique ID for traces
func generateID() string {
	return fmt.Sprintf("%d", time.Now().UnixNano())
}
